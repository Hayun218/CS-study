작성일시: 24.10.21 (Mon)

1. **컴퓨터 시스템에서 CPU, RAM, 저장 장치의 역할과 이들이 어떻게 상호 작용하는지 설명해주세요.**

	- **CPU(중앙 처리 장치)**: CPU는 컴퓨터의 두뇌에 해당합니다. 명령어를 해석하고 실행하며, 연산과 제어를 담당합니다. 프로그램 실행, 산술 및 논리 연산, 제어 신호 전송 등 다양한 기능을 수행합니다.
	- **RAM(메인 메모리)**: RAM은 데이터를 일시적으로 저장하는 장치로, CPU가 현재 처리 중인 데이터를 빠르게 읽고 쓸 수 있도록 합니다. RAM에 저장된 데이터는 휘발성이 있어 전원이 꺼지면 사라집니다.
	- **저장 장치(하드 드라이브, SSD)**: 하드 드라이브나 SSD는 데이터를 영구적으로 저장하는 장치입니다. 운영체제, 프로그램, 파일들이 저장되며, 필요할 때 RAM으로 데이터를 불러와 CPU에서 처리할 수 있게 합니다.
	  
	**상호작용**: 
	CPU는 저장 장치에 직접적으로 접근하지 않고, 우선적으로 RAM에서 데이터를 가져옵니다. 프로그램을 실행하면, 저장 장치에 저장된 프로그램의 데이터가 RAM으로 로드되고, CPU가 이 데이터를 처리합니다. 만약 필요한 데이터가 RAM에 없으면 저장 장치에서 다시 가져오는 과정을 거칩니다.

	1-1. CPU와 메모리 간의 데이터 교환은 어떻게 이루어지나요?
	1-2. 버스(Bus)란 무엇이며, 어떤 종류가 있나요?
	
	CPU는 메모리(RAM)와 **버스(bus)** 를 통해 데이터를 교환합니다. 
	이때 버스는 CPU와 메모리 또는 다른 장치 간의 데이터 전달 경로입니다.
	
	- 주소 버스(address bus): CPU가 메모리의 특정 위치에 접근하기 위한 주소 정보를 전달합니다.
	- 데이터 버스(data bus): CPU와 메모리 간에 실제 데이터를 주고받는 역할을 합니다.
	- 제어 버스(control bus): 데이터 전송을 제어하는 신호를 보내고, 데이터의 읽기/쓰기와 같은 동작을 조절합니다.

  
2. **캐시 메모리의 개념과 역할에 대해 설명해주세요.**
   
	캐시 메모리(cache memory)는 CPU와 메인 메모리(RAM) 사이에 위치하여, CPU가 자주 사용하는 데이터를 빠르게 접근할 수 있도록 하는 고속 메모리입니다. RAM보다 훨씬 빠른 속도를 제공하며, CPU의 작업 효율을 높여줍니다. CPU는 데이터 접근 시 우선적으로 캐시에서 데이터를 찾고, 없으면 RAM에서 데이터를 가져옵니다.

    2-1. 캐시의 지역성(Locality) 원리에 대해 설명해주세요.
    
    - **시간적 지역성(Temporal Locality)**: 최근에 접근한 데이터는 다시 접근할 가능성이 높다는 원리입니다. 따라서 자주 사용된 데이터는 캐시에 저장됩니다.
    - **공간적 지역성(Spatial Locality)**: 특정 데이터에 접근한 후 그 주변 데이터도 접근할 가능성이 높다는 원리입니다. 즉, 인접한 메모리 영역이 캐시에 함께 로드됩니다.


3.  **CPU 아키텍처의 종류(예: ARM, x86)와 각 특징에 대해 설명해주세요.**
   
	ARM: ARM(Advanced RISC Machine)은 저전력 소모와 효율성을 중시하는 RISC(간소화 명령어 집합 컴퓨터) 아키텍처입니다. 주로 모바일 기기, 임베디드 시스템에 사용되며, 배터리 효율성이 중요합니다.
	
	x86: x86은 인텔에서 개발한 CISC(복잡 명령어 집합 컴퓨터) 아키텍처입니다. 복잡한 명령어를 처리할 수 있으며, 주로 데스크탑이나 서버 컴퓨터에 사용됩니다.
   

4.  **iOS 기기에서 사용되는 AP(Application Processor)의 특징과 역할에 대해 설명해주세요.**

	AP(Application Processor)는 스마트폰과 같은 모바일 장치에서 CPU, GPU, 메모리 제어기 등을 통합한 핵심 프로세서입니다. iOS 기기에서 AP는 iPhone의 모든 연산, 그래픽 처리, 그리고 센서 제어까지 담당합니다. Apple의 AP, 예를 들어 A 시리즈 칩(A14, A15 등)은 ARM 기반의 아키텍처를 사용하며, iOS의 성능을 최적화하기 위해 특별히 설계되었습니다.

	4-1. SoC(System on a Chip)의 개념은 무엇인가요?
	
	SoC(System on a Chip)는 CPU, GPU, 메모리, 무선 통신 모듈, 그리고 기타 컴퓨팅 구성 요소들을 하나의 칩에 통합한 것입니다. SoC는 작은 크기와 효율성을 바탕으로 스마트폰, 태블릿 등 모바일 장치에서 사용됩니다. 하나의 칩에 여러 기능을 집약하여 전력 소모를 줄이고, 공간을 절약합니다.


5.  **운영체제의 역할과 iOS의 운영체제 구조에 대해 설명해주세요.**
   
	운영체제(OS)는 하드웨어 자원을 관리하고, 사용자와 소프트웨어 간의 인터페이스를 제공합니다. 주요 기능은 프로세스 관리, 메모리 관리, 파일 시스템 관리, 디바이스 제어 등입니다.
	
	iOS는 Apple의 모바일 운영체제이며, Darwin 커널을 기반으로 합니다. iOS는 다음과 같은 계층 구조를 가집니다:
	
	- Core OS: 커널과 기본 시스템 서비스, 보안, 파일 시스템 관리.
	- Core Services: 네트워크, 위치 서비스, 데이터 관리 등 핵심 서비스 제공.
	- Media Layer: 그래픽, 오디오, 비디오 처리 기능 제공.
	- Cocoa Touch: iOS 앱을 위한 UI 및 이벤트 처리 계층.

    5-1. iOS의 샌드박스 구조는 어떻게 동작하나요?
    
    iOS는 샌드박스 구조를 통해 각 앱이 독립된 환경에서 실행되도록 하여 보안을 강화합니다. 앱은 다른 앱의 데이터를 접근할 수 없으며, 운영체제가 허용하는 자원만 사용할 수 있습니다. 이로 인해 악성 앱이 시스템 전체에 영향을 미치는 것을 방지합니다.

    5-2. 커널(Kernel)의 역할은 무엇인가요?
    
    커널은 운영체제의 핵심 부분으로, 하드웨어와 소프트웨어 간의 상호작용을 관리합니다. 메모리 관리, 프로세스 제어, 하드웨어 장치 제어, 파일 시스템 관리 등의 기능을 제공합니다.

    5-3. 다중 태스킹(Multitasking)은 어떻게 지원되나요?
    
    iOS는 다중 태스킹을 지원하여 여러 앱이 동시에 실행될 수 있도록 합니다. iOS에서는 백그라운드에서 실행되는 앱을 관리하고, 앱이 자원을 효율적으로 사용할 수 있도록 백그라운드 작업을 제어합니다. 백그라운드 모드, 푸시 알림, 백그라운드 작업 업데이트 등이 다중 태스킹을 지원하는 주요 기능입니다.


6.  **프로세스와 스레드의 차이점, 그리고 iOS에서의 프로세스와 스레드 관리 방법에 대해 설명해주세요.**

	프로세스: 프로세스는 실행 중인 프로그램을 의미하며, 독립된 메모리 공간을 가지고 CPU, 메모리, 파일 등을 사용하는 하나의 작업 단위입니다. 각 프로세스는 자체 주소 공간을 가지며, 다른 프로세스와 메모리 공간을 공유하지 않습니다. 프로세스 간의 통신은 복잡하며, 주로 IPC(Inter-Process Communication)를 통해 이루어집니다.
	
	스레드: 스레드는 프로세스 내에서 실행되는 작업의 작은 단위입니다. 하나의 프로세스는 여러 스레드를 가질 수 있으며, 이들은 프로세스 내에서 메모리와 자원을 공유합니다. 스레드 간의 통신은 상대적으로 빠르고 간단하지만, 자원 공유로 인해 동기화 문제가 발생할 수 있습니다.
	
	**iOS에서의 관리:**
	
	iOS에서는 프로세스가 앱 단위로 관리됩니다. 각 앱은 독립된 프로세스로 실행되며, 샌드박스 환경에서 실행되어 다른 앱의 프로세스와 격리됩니다.
	스레드는 주로 Grand Central Dispatch(GCD) 또는 NSOperation을 통해 관리되며, 멀티스레딩을 효율적으로 처리할 수 있도록 도와줍니다.

    6-1. 멀티스레딩이 필요한 이유는 무엇인가요?
    
	멀티스레딩은 여러 작업을 동시에 처리할 수 있도록 하는 기술입니다. 이를 통해 CPU 자원을 보다 효율적으로 사용하며, 다음과 같은 이점이 있습니다:
	
	- **병렬 처리**: 멀티코어 CPU에서 작업을 병렬로 처리하여 성능을 극대화할 수 있습니다.
	- **UI 반응성 개선**: 네트워크 요청이나 파일 입출력 같은 시간이 오래 걸리는 작업을 별도의 스레드에서 처리하여 UI가 멈추지 않도록 할 수 있습니다.
	- **리소스 활용**: 여러 스레드를 사용하면 대기 시간이 긴 작업을 비동기적으로 처리하여 시스템 리소스를 효율적으로 사용할 수 있습니다.

    6-2. iOS에서 GCD(Grand Central Dispatch)는 어떤 역할을 하나요?
    
	GCD는 iOS에서 멀티스레딩을 쉽게 관리할 수 있도록 제공되는 라이브러리입니다. GCD는 작업을 큐(queue)에 넣고, 운영체제가 적절한 스레드에서 해당 작업을 실행하도록 합니다. 주요 역할은 다음과 같습니다:
	
	- **동시성 처리**: GCD는 여러 작업을 동시에 처리하는 동시성(concurrency)을 지원합니다.
	- **비동기 작업 처리**: 네트워크 요청, 파일 입출력, UI 업데이트 등을 비동기적으로 처리할 수 있어, 메인 스레드에서 작업을 처리하는 동안 UI가 멈추지 않도록 도와줍니다.
	- **스레드 풀 관리**: 개발자가 직접 스레드를 생성하거나 관리할 필요 없이, GCD가 스레드를 효율적으로 할당하고 관리합니다.


7. **메모리 관리 기법 중 iOS에서 사용되는 방식과 그 특징에 대해 설명해주세요.**
   
	iOS는 자동 참조 카운팅(ARC, Automatic Reference Counting)을 사용하여 메모리를 관리합니다. ARC는 컴파일러가 객체의 메모리 관리를 자동으로 수행하여, 개발자가 명시적으로 메모리 할당과 해제를 할 필요가 없습니다.

    7-1. 자동 참조 카운팅(ARC)은 어떻게 동작하나요?
    
    ARC는 객체의 참조 카운트(reference count)를 추적하여, 더 이상 참조되지 않는 객체의 메모리를 자동으로 해제합니다. 객체를 참조할 때마다 참조 카운트가 증가하고, 참조가 없어질 때마다 카운트가 감소합니다. 참조 카운트가 0이 되면 해당 객체의 메모리가 해제됩니다.
    
	- **강한 참조(strong reference)**: 객체의 참조 카운트를 증가시키는 참조입니다.
	- **약한 참조(weak reference)**: 객체의 참조 카운트를 증가시키지 않으며, 참조하는 객체가 해제되면 `nil`로 설정됩니다.

    7-2. Garbage Collection과의 차이는 무엇인가요?
    
    - **ARC**는 컴파일 타임에 객체의 수명 주기를 결정하며, 참조 카운트를 기반으로 메모리를 관리합니다.
	- **Garbage Collection**은 런타임에 주기적으로 메모리를 검사하여, 더 이상 참조되지 않는 객체를 해제합니다. 이는 메모리 해제를 즉각적으로 하지 않기 때문에 성능에 영향을 미칠 수 있습니다.
  
  
8. **iOS의 샌드박스(Sandbox) 개념과 역할, 그리고 앱 간 데이터 공유 방법에 대해 설명해주세요.**

    iOS는 **샌드박스**를 통해 각 앱이 독립된 환경에서 실행되도록 하여 보안을 강화합니다. 앱은 자신의 파일 시스템에만 접근할 수 있고, 다른 앱이나 시스템 자원에 접근할 수 없습니다. 이러한 구조는 악성 코드가 시스템이나 다른 앱에 영향을 미치는 것을 방지합니다.

    8-1. URL 스킴(URL Scheme)을 이용한 앱 간 통신은 어떻게 이루어지나요?
    
    iOS 앱 간 통신은 주로 URL 스킴을 통해 이루어집니다. URL 스킴은 하나의 앱이 다른 앱을 열어 특정 작업을 수행하게 하는 방식입니다. 예를 들어, 한 앱에서 URL 스킴을 통해 다른 앱을 호출하고 데이터를 전달할 수 있습니다.

    8-2. 앱 그룹(App Group)을 활용하여 데이터 공유를 하는 방법은 무엇인가요?
    
    **앱 그룹**은 여러 앱이 동일한 그룹에 속할 때 데이터를 공유할 수 있는 방법입니다. 앱 그룹을 사용하면 앱 간에 파일, 사용자 설정 등을 공유할 수 있습니다. 이를 위해 **UserDefaults**나 **파일 시스템**을 활용하여 데이터를 저장하고 읽을 수 있습니다.


9. **iOS에서의 메모리 구조와 관리 방식에 대해 자세히 설명해주세요.**
   
    iOS는 **스택(Stack)** 과 **힙(Heap)** 을 포함하는 메모리 구조를 관리합니다.
    
	- **스택(Stack)**: 함수 호출, 지역 변수 등을 저장하는 메모리 공간입니다. 스택은 메모리를 정적으로 할당하며, LIFO(Last In, First Out) 방식으로 관리됩니다. 스택은 크기가 작고 매우 빠르지만, 한정된 메모리를 사용할 수 있습니다.
    
	- **힙(Heap)**: 동적으로 할당된 메모리를 저장하는 공간입니다. 객체나 배열과 같은 동적 데이터는 힙에 할당되며, 개발자가 수동으로 할당과 해제를 관리할 필요가 있습니다. 힙은 더 큰 메모리 공간을 제공하지만, 할당 및 해제 작업이 상대적으로 느립니다.

	9-1. 힙(Heap)과 스택(Stack)의 차이점은 무엇인가요?
	
    -  **메모리 할당 방식**: 스택은 정적 메모리 할당, 힙은 동적 메모리 할당을 사용합니다.
	- **속도**: 스택은 메모리 할당과 해제가 매우 빠릅니다. 반면 힙은 동적 할당과 해제가 필요하므로 상대적으로 느립니다.
	- **메모리 크기**: 스택은 크기가 제한되어 있지만, 힙은 매우 큰 메모리 영역을 사용할 수 있습니다.
	- **관리 방식**: 스택은 운영체제가 자동으로 관리하고, 힙은 개발자가 관리해야 합니다.

  
10. **네트워크 프로토콜 스택과 iOS에서의 네트워크 통신 방식에 대해 설명해주세요.**

	네트워크 프로토콜 스택은 네트워크 통신이 이루어지는 계층 구조로, 각 계층이 특정한 역할을 담당합니다. **iOS**는 네트워크 통신을 위해 TCP/IP 스택을 사용하며, 다양한 네트워크 프로토콜을 지원합니다. iOS에서의 네트워크 통신 방식은 주로 **NSURLSession**을 활용하여 HTTP/HTTPS를 통해 데이터를 송수신합니다.

	 **iOS에서의 네트워크 통신 방식:**
	
	- **NSURLSession**: iOS에서 네트워크 요청을 관리하는 기본 클래스입니다. HTTP/HTTPS 요청을 비동기적으로 처리하며, 파일 다운로드, 데이터 업로드, API 호출 등을 지원합니다.
	- **WebSocket**: 실시간 양방향 통신을 위해 iOS에서는 WebSocket을 사용할 수 있습니다. 실시간 데이터를 빠르게 전송할 수 있는 웹 표준입니다.
	- **TCP/UDP**: iOS에서도 TCP와 UDP 기반의 소켓 통신을 지원하며, 낮은 수준의 네트워크 프로그래밍이 가능합니다. 이 경우 **CFNetwork** 또는 **BSD 소켓**을 사용합니다    


11. **HTTP와 HTTPS의 차이점, 그리고 iOS에서의 보안 통신 방법에 대해 설명해주세요.**
	
	- **HTTP (HyperText Transfer Protocol)**: 인터넷 상에서 데이터를 주고받는 표준 프로토콜로, 텍스트 기반의 통신입니다. HTTP는 보안이 설정되어 있지 않기 때문에 데이터가 평문으로 전송되며, 공격자에 의해 쉽게 가로챌 수 있습니다.
	  
	- **HTTPS (HyperText Transfer Protocol Secure)**: HTTP에 보안 계층(SSL/TLS)이 추가된 프로토콜입니다. HTTPS는 데이터를 암호화하여 전송하므로, 제3자가 데이터를 도청하거나 변조할 수 없습니다. HTTPS는 기본적으로 SSL/TLS를 사용해 보안성을 보장합니다.
	  
	**iOS에서의 보안 통신 방법:**
	   
	iOS에서 보안 통신을 구현하는 방법은 **HTTPS**를 사용하는 것입니다. Apple은 앱에서 HTTPS 통신을 권장하며, **ATS(App Transport Security)**를 통해 앱이 안전한 통신 방법을 따르도록 강제하고 있습니다. ATS는 iOS 9 이후로 기본 설정으로 적용되며, 기본적으로 SSL/TLS 암호화된 통신을 요구합니다    

    11-1. SSL/TLS의 동작 원리는 무엇인가요?
    
    SSL/TLS는 클라이언트와 서버 간의 통신을 암호화하여 보안성을 제공하는 프로토콜입니다.
    
	- **핸드셰이크 과정**: 클라이언트와 서버가 통신하기 전에 암호화 방식과 세션 키를 설정하는 과정입니다.
	    1. **클라이언트 헬로(Client Hello)**: 클라이언트가 서버에 암호화 알고리즘 목록과 TLS 버전을 제시합니다.
	    2. **서버 헬로(Server Hello)**: 서버는 그 목록에서 사용할 암호화 알고리즘과 서버의 인증서(공개 키 포함)를 클라이언트에 전달합니다.
	    3. **인증서 검증**: 클라이언트는 서버 인증서를 확인하고 신뢰할 수 있는 인증 기관에서 발급된 것인지 확인합니다.
	    4. **세션 키 생성**: 클라이언트와 서버는 대칭 키 암호화를 위해 세션 키를 교환합니다.
	    5. **암호화된 통신 시작**: 양쪽은 세션 키를 사용해 암호화된 데이터 통신을 진행합니다.


12. **컴퓨터 네트워킹에서 OSI 7계층 모델에 대해 설명해주세요.**
    
	**OSI(Open Systems Interconnection) 모델**은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 통신 과정에서 담당하는 역할을 분리하여 설명하는 모델입니다.

    12-1. 각 계층의 역할과 프로토콜은 무엇인가요?
    
	1. **물리 계층(Physical Layer)**: 데이터 전송을 위한 물리적인 하드웨어 장치와 매체를 정의합니다. 전기 신호, 빛, 전송 케이블 등이 포함됩니다.
	    - **프로토콜**: 이더넷, RS-232 등.
	      
	2. **데이터 링크 계층(Data Link Layer)**: 물리 계층에서 오류 없이 데이터가 전송되도록 하며, MAC 주소를 사용하여 장치 간의 통신을 관리합니다.
	    - **프로토콜**: 이더넷, PPP, HDLC, ARP 등.
	      
	3. **네트워크 계층(Network Layer)**: 데이터를 목적지까지 전달하기 위한 경로를 결정합니다. IP 주소를 사용하여 라우팅을 관리합니다.
	    - **프로토콜**: IP(IPv4, IPv6), ICMP, IGMP 등.
	      
	4. **전송 계층(Transport Layer)**: 송신자와 수신자 간에 신뢰성 있는 데이터 전송을 제공합니다. 포트를 사용하여 여러 애플리케이션 간의 데이터 전송을 구분합니다.
	    - **프로토콜**: TCP, UDP 등.
	      
	5. **세션 계층(Session Layer)**: 송수신 간의 대화(세션)를 설정하고, 유지하며, 종료합니다. 세션 중에 발생할 수 있는 통신 오류를 처리합니다.
	    - **프로토콜**: NetBIOS, PPTP 등.
	      
	6. **표현 계층(Presentation Layer)**: 데이터를 응용 계층에서 사용할 수 있도록 변환하며, 암호화 및 압축을 수행합니다.
	    - **프로토콜**: SSL, TLS, JPEG, GIF 등.
	      
	7. **응용 계층(Application Layer)**: 사용자와 직접 상호작용하는 인터페이스를 제공합니다. 웹 브라우저, 이메일 등 애플리케이션 프로그램이 이 계층에서 동작합니다.
		- **프로토콜**: HTTP, FTP, SMTP, DNS 등.

    12-2. TCP/IP 모델과 OSI 모델의 차이점은 무엇인가요?
    
    **TCP/IP 모델**은 OSI 모델과 달리 4계층 구조로 간단하게 통신 프로토콜을 설명합니다. 실질적으로 오늘날 인터넷에서 사용하는 프로토콜 모델입니다.
	- **TCP/IP 모델의 4계층**:
	    1. **네트워크 인터페이스 계층**: 물리 계층과 데이터 링크 계층에 해당하는 부분으로, 네트워크 하드웨어와 연결된 물리적 데이터 전송을 담당합니다.
	    2. **인터넷 계층**: IP 주소를 기반으로 한 네트워크 계층입니다. 라우팅 및 데이터 패킷 전달을 담당합니다.
	    3. **전송 계층**: TCP/UDP를 사용해 신뢰성 있는 데이터 전송을 담당합니다.
	    4. **응용 계층**: 웹, 이메일, 파일 전송 등 사용자 인터페이스와 직접 연결된 응용 계층입니다.
	
	**차이점**:
	- OSI 모델은 7계층으로 나누어 더 구체적이며, 계층별로 명확한 구분이 있습니다.
	- TCP/IP 모델은 실무에 더 적합하게 만들어졌으며, 4계층으로 간단하게 구성되어 있습니다. OSI 모델은 이론적이고, TCP/IP 모델은 실제 네트워크 통신에 더 많이 사용됩니다.

  
13. **HTTP 프로토콜의 특징과 HTTP/1.1과 HTTP/2의 차이점을 설명해주세요.**

    HTTP 프로토콜의 특징:
	- **무상태성(Stateless)**: HTTP는 무상태 프로토콜입니다. 즉, 서버는 클라이언트의 이전 요청에 대한 상태를 기억하지 않습니다. 각 요청은 독립적으로 처리되며, 새로운 연결이 이루어질 때마다 서버는 클라이언트의 상태를 다시 파악해야 합니다.
	- **텍스트 기반**: HTTP는 인간이 읽을 수 있는 텍스트 기반 프로토콜로, 클라이언트와 서버 간의 요청과 응답은 텍스트로 이루어집니다.
	- **애플리케이션 계층 프로토콜**: HTTP는 OSI 모델의 애플리케이션 계층에 속하며, 주로 웹 브라우저와 서버 간의 통신을 담당합니다.

    13-1. HTTP의 무상태(Stateless) 성질은 무엇이며, 어떻게 극복하나요?
    
    HTTP는 무상태이므로 클라이언트와 서버 간의 요청이 독립적으로 처리되어 이전의 요청 상태를 유지하지 않습니다. 이를 극복하기 위해 다음과 같은 방법이 사용됩니다:
    
	- **쿠키(Cookies)**: 서버가 클라이언트의 상태를 기억하기 위해 클라이언트 측에 작은 데이터를 저장합니다.
	- **세션(Session)**: 서버 측에서 클라이언트의 상태를 기억하고 세션 ID를 통해 클라이언트를 식별합니다.
	- **JWT(JSON Web Token)**: 상태를 클라이언트 측에서 유지하기 위해, 서버는 JWT를 발급하여 클라이언트가 이를 전달함으로써 상태를 유지합니다.

    13-2. HTTP/2에서 추가된 주요 기능은 무엇인가요?
    
    HTTP/1.1과 HTTP/2의 차이점:
	- **HTTP/1.1**: 클라이언트와 서버는 요청마다 새로운 연결을 열고 닫습니다. **Keep-Alive**가 적용되었지만, 여전히 하나의 연결에서 하나의 요청만 처리할 수 있어 비효율적입니다.
	- **HTTP/2**: 성능을 개선하기 위해 여러 기능이 추가되었습니다.
	    - **멀티플렉싱(Multiplexing)**: 하나의 TCP 연결에서 여러 요청과 응답을 동시에 처리할 수 있습니다. 이를 통해 HTTP/1.1의 문제인 '헤드 오브 라인 블로킹'을 해결
	    - **헤더 압축**: 요청과 응답 헤더를 압축하여 네트워크 대역폭을 절약하고, 성능을 향상
	    - **서버 푸시(Server Push)**: 서버는 클라이언트가 요청하지 않은 리소스를 미리 전송하여 필요한 리소스를 클라이언트가 빠르게 받을 수 있음

    13-3. HTTP/3에서 추가된 기능은 무엇인가요?
    
    - **HTTP/3**는 기존의 TCP 대신 **QUIC**(Quick UDP Internet Connections)를 기반으로 합니다.
    - **QUIC 프로토콜**: UDP를 기반으로 하지만 TCP의 신뢰성 있는 연결 성질을 추가하여 성능을 개선합니다.
    - **0-RTT 연결**: 첫 번째 요청 시점부터 데이터를 전송할 수 있어 연결 성립 속도를 크게 줄입니다.
    - **헤드 오브 라인 블로킹 제거**: TCP의 문제점인 '헤드 오브 라인 블로킹'을 완전히 제거하였으며, 개별 스트림에서의 손실만 재전송이 발생합니다.


14. **TCP와 UDP의 특징과 차이점에 대해 설명해주세요.**
    
    TCP와 UDP의 특징: 
	- **TCP(Transmission Control Protocol)**:
	    - 연결 지향형 프로토콜입니다. 통신을 시작하기 전에 송신자와 수신자가 연결을 설정(3-way handshake)해야 합니다.
	    - 데이터 전송의 신뢰성을 보장하며, 데이터가 손실되면 재전송합니다.
	    - 데이터의 순서가 보장되며, 패킷이 순서대로 도착하지 않으면 재조합하여 처리합니다.
	    - 오류 검출 및 수정 기능이 있어 안정적인 통신을 보장합니다.
	      
	- **UDP(User Datagram Protocol)**:
	    - 비연결 지향형 프로토콜입니다. 송신자와 수신자는 연결을 설정하지 않고, 데이터를 전송합니다.
	    - 신뢰성이 없으며, 데이터가 손실되거나 순서가 틀리더라도 재전송을 하지 않습니다.
	    - 매우 간단하고 빠르며, 오버헤드가 적습니다.
	    - 데이터 전송의 순서가 보장되지 않으며, 오류 검출이 불완전합니다.

	14-1. 연결 지향형 프로토콜과 비연결 지향형 프로토콜은 무엇인가요?
	
	- **연결 지향형 프로토콜**: 송신자와 수신자가 먼저 연결을 설정한 후 데이터를 주고받는 방식입니다. 연결을 유지하면서 데이터 전송을 보장합니다. TCP가 이에 해당합니다.
	- **비연결 지향형 프로토콜**: 연결을 설정하지 않고 데이터를 전송하며, 패킷을 받는 즉시 처리합니다. 데이터 전송의 신뢰성은 없지만 빠른 전송 속도를 제공합니다. UDP가 이에 해당합니다.

	14-2. TCP의 3-way handshake 과정은 어떻게 이루어지나요?
	
	TCP는 신뢰성 있는 연결을 설정하기 위해 **3-way handshake**를 사용합니다.
	
	1. **SYN**: 클라이언트가 서버에 연결을 요청하는 메시지(SYN)를 보냅니다.
	2. **SYN-ACK**: 서버는 요청을 수락한다는 의미로 SYN과 ACK 메시지를 클라이언트에 보냅니다.
	3. **ACK**: 클라이언트는 서버의 응답을 확인했다는 ACK 메시지를 보냅니다. 이로써 연결이 성립됩니다.

	14-3.  어떤 상황에서 UDP를 사용하는 것이 적합한가요?
	
	UDP는 빠른 전송이 중요하지만, 데이터의 신뢰성보다는 속도가 우선시되는 경우에 적합합니다.
	
	- **스트리밍 서비스**: 비디오 또는 오디오 스트리밍에서는 약간의 데이터 손실이 있어도 큰 문제가 없으며, 실시간 전송이 중요합니다.
	- **온라인 게임**: 빠른 반응이 필요한 게임에서는 약간의 데이터 손실보다 속도가 중요합니다.
	- **VoIP(Voice over IP)**: 실시간 음성 통신에서도 빠른 데이터 전송이 중요하며, 데이터 손실이 발생하더라도 속도가 우선됩니다.


15. **소켓 통신에 대해 설명해주세요.**

    **소켓 통신**은 네트워크 상에서 두 컴퓨터 간에 데이터를 주고받기 위해 사용하는 양방향 통신 방식입니다. 소켓은 IP 주소와 포트 번호를 사용하여 클라이언트와 서버 간의 연결을 설정하고 데이터를 주고받습니다. 소켓은 전송 계층에서 사용되며, 주로 **TCP** 또는 **UDP** 프로토콜을 기반으로 동작합니다.


16. **REST API와 iOS에서의 네트워크 요청 및 응답 처리 방법에 대해 설명해주세요.**

    REST API란?
    
	**REST(Representational State Transfer)** API는 클라이언트와 서버 간의 통신을 위해 HTTP 프로토콜을 기반으로 하는 아키텍처 스타일입니다. REST는 리소스를 URI로 표현하며, 리소스에 대한 CRUD(Create, Read, Update, Delete) 작업을 HTTP 메서드(POST, GET, PUT, DELETE)로 정의합니다.
	
	REST API는 무상태(stateless)이며, 각 요청은 독립적이고, 필요한 모든 정보를 포함합니다. 이를 통해 클라이언트는 서버에서 데이터를 요청하고, 서버는 응답을 통해 데이터를 반환합니다.
	
	 iOS에서 REST API를 사용하는 방법:
	 
	iOS에서는 **`URLSession`** 클래스를 사용하여 네트워크 요청을 보내고 응답을 처리합니다. `URLSession`은 비동기적인 HTTP 요청을 처리하며, 데이터를 서버로 전송하거나 서버에서 데이터를 수신하는 데 사용됩니다.
    

    16-1. iOS에서 `URLSession`을 사용하여 네트워크 요청을 보내는 방법은 무엇인가요?
    
    `URLSession`은 iOS에서 HTTP 요청을 처리하는 기본적인 방법입니다. 비동기적으로 네트워크 통신을 수행하며, 클로저를 통해 응답을 처리합니다.
    
	1. **URL 생성**: 통신할 서버의 URL 설정.
	2. **URLRequest 설정**: 메서드 및 헤더 설정.
	3. **URLSession 데이터 태스크 생성**: 네트워크 요청을 비동기적으로 처리.
	4. **태스크 실행**: `resume()` 메서드를 호출해 네트워크 요청을 시작.


17. **REST API에서 HTTP 메서드들의 차이점을 설명해주세요.**

    REST API는 다양한 **HTTP 메서드**를 사용하여 서버의 리소스를 조작합니다. 각 메서드는 특정한 동작을 수행합니다:
    
	- **GET**: 서버에서 데이터를 요청하여 가져오는 메서드입니다. 주로 데이터를 읽을 때 사용되며, 서버의 상태나 데이터에 영향을 주지 않습니다. 요청에 데이터가 포함되지 않고, URL에 쿼리 매개변수로 전달됩니다.
	- **POST**: 서버에 데이터를 전송하고 새로운 리소스를 생성하거나 서버 상태를 변경하는 데 사용됩니다. 클라이언트에서 서버로 전송되는 데이터는 주로 요청 본문에 포함됩니다.
	- **PUT**: 서버에 리소스를 생성하거나 기존 리소스를 업데이트할 때 사용됩니다. 이미 존재하는 리소스를 덮어쓸 수 있습니다.
	- **DELETE**: 서버에서 리소스를 삭제할 때 사용됩니다.
	- **PATCH**: 기존 리소스의 일부를 수정할 때 사용됩니다. **PUT**은 전체 리소스를 업데이트하는 반면, **PATCH**는 부분적인 수정만 수행합니다.
    

    17-1. `GET`과 `POST`의 차이점은 무엇인가요?
    
    **GET**:
    - 데이터를 서버에서 **가져올 때** 사용됩니다.
    - **URL**에 쿼리 매개변수로 데이터를 전달하며, URL이 길어질 수 있습니다.
    - 데이터 전송량이 제한될 수 있고, 보안에 취약할 수 있습니다(데이터가 URL에 노출됨).
    - **캐시 가능**하며, 서버의 상태나 데이터를 변경하지 않습니다.
      
	**POST**:
    - 데이터를 서버에 **전송하고, 리소스를 생성하거나 수정할 때** 사용됩니다.
    - 데이터는 **본문**(body)에 포함되며, URL에 노출되지 않아 GET보다 상대적으로 안전합니다.
    - 전송 데이터 양이 많을 수 있고, 서버의 상태나 데이터를 변경할 수 있습니다.
    - **캐시되지 않으며**, 주로 보안이 필요한 데이터 전송에 사용됩니다.


18. **HTTP 상태 코드에 대해서 설명해주세요.**

    HTTP 상태 코드는 클라이언트가 보낸 요청에 대한 서버의 응답을 나타냅니다. 각 상태 코드는 3자리 숫자로 구분되며, 주요 범주는 다음과 같습니다:
    
	- **1xx (정보)**: 요청이 처리 중이라는 의미로, 주로 서버가 요청을 더 처리할 준비가 되었음을 나타냅니다.
	    - 예: 100 Continue
	      
	- **2xx (성공)**: 요청이 성공적으로 처리되었음을 나타냅니다.
	    - 예: 200 OK, 201 Created
	      
	- **3xx (리다이렉션)**: 클라이언트가 요청한 리소스를 다른 위치에서 찾아야 함을 의미합니다.
	    - 예: 301 Moved Permanently, 302 Found
	      
	- **4xx (클라이언트 오류)**: 클라이언트의 잘못된 요청을 나타냅니다.
	    - 예: 400 Bad Request, 401 Unauthorized, 404 Not Found
	      
	- **5xx (서버 오류)**: 서버가 요청을 처리하는 도중 오류가 발생했음을 나타냅니다.
	    - 예: 500 Internal Server Error, 503 Service Unavailable


19. **iOS에서 이미지 파일 포맷(PNG, JPEG 등)과 각 포맷의 특징에 대해 설명해주세요.**

    각 포맷은 이미지 압축 및 품질에서 차이가 있습니다.
    
	- **PNG (Portable Network Graphics)**:
	    - **무손실 압축**을 사용하여 이미지의 품질을 그대로 유지하면서 파일 크기를 줄입니다.
	    - **투명도(알파 채널)**를 지원하여 배경이 투명한 이미지를 처리할 수 있습니다.
	    - 주로 고화질 이미지, 아이콘, UI 요소에서 사용됩니다.
	- **JPEG (Joint Photographic Experts Group)**:
	    - **손실 압축**을 사용하여 이미지 품질을 희생하면서 파일 크기를 크게 줄입니다.
	    - 투명도를 지원하지 않으며, 사진과 같이 색상이 많은 이미지를 저장할 때 주로 사용됩니다.
	    - 고화질 이미지가 필요 없는 상황에서 파일 크기를 줄이는 데 적합합니다.

    19-1.  PNG와 JPEG의 차이점은 무엇인가요?
    
    - **압축 방식**:
	    - **PNG**: 무손실 압축을 사용하여 이미지 품질을 그대로 유지합니다.
	    - **JPEG**: 손실 압축을 사용하여 품질을 희생하고 파일 크기를 줄입니다.
	- **투명도**:
	    - **PNG**: 투명도(알파 채널)를 지원합니다.
	    - **JPEG**: 투명도를 지원하지 않습니다.
	- **사용 사례**:
	    - **PNG**: UI 요소, 로고, 아이콘과 같이 품질 손실이 없어야 하는 이미지에 사용됩니다.
	    - **JPEG**: 파일 크기를 줄여야 하는 사진과 같은 복잡한 이미지에 사용됩니다.


20. **PNG 파일이 어떻게 저장되고 구성되는지 설명해주세요.**

    **PNG 파일**은 **무손실 압축**을 사용하여 이미지를 저장하며, 다음과 같은 방식으로 구성됩니다:
    
	1. **헤더**: PNG 파일의 시작 부분에 있는 헤더는 파일이 PNG 형식임을 나타내며, 파일의 기본적인 정보를 포함합니다.
	2. **이미지 데이터**: PNG는 이미지 데이터를 저장할 때 **필터링**과 **압축** 과정을 거칩니다. 이 데이터는 **무손실 압축** 알고리즘인 **Deflate**로 압축되어 저장됩니다.
	3. **알파 채널**: PNG는 투명도를 표현하기 위해 알파 채널을 사용할 수 있습니다. 이를 통해 이미지의 각 픽셀에 대해 투명도를 정의할 수 있습니다.
	4. **CRC**: 파일의 무결성을 확인하기 위한 **CRC (Cyclic Redundancy Check)** 값이 포함되어 있습니다.
	5. **IDAT 청크**: 압축된 이미지 데이터를 담고 있는 청크(chunks)입니다. 여러 개의 IDAT 청크가 있을 수 있으며, 모든 청크를 결합해 원래 이미지를 복원합니다.
    


21. **iOS에서 메모리 사이즈와 관련된 개념과 고려 사항에 대해 설명해주세요.**

    iOS 앱을 개발할 때 메모리 관리가 매우 중요합니다. 특히, 모바일 디바이스는 데스크탑에 비해 메모리가 제한되어 있으므로, 효율적인 메모리 사용이 필요합니다. iOS에서 메모리와 관련된 주요 개념은 다음과 같습니다:
	
	- **메모리 관리**: iOS는 자동 참조 카운팅(ARC)을 사용하여 메모리 관리를 자동화합니다. 객체의 참조 카운트가 0이 되면 메모리가 해제됩니다.
	- **메모리 최적화**: 불필요한 메모리 사용을 줄이기 위해, 사용하지 않는 객체는 적시에 해제하고, 메모리 캐시 사용을 최적화하는 것이 필요합니다.
	- **메모리 정렬(Alignment)**: CPU가 데이터를 메모리에서 빠르게 읽고 쓰기 위해 메모리 주소가 일정한 크기(정렬)에 맞추어 할당됩니다.

    21-1.메모리 정렬(Alignment)이 성능에 미치는 영향은 무엇인가요?
    
    메모리 정렬은 메모리 주소가 특정 바이트 경계에 맞춰 할당되는 방식입니다. 데이터가 잘 정렬되면 CPU가 더 빠르게 메모리에 접근할 수 있습니다. 잘못 정렬된 데이터는 여러 번의 메모리 접근이 필요할 수 있어 성능 저하가 발생할 수 있습니다. 특히, 메모리 접근이 빈번한 연산에서는 정렬이 성능에 큰 영향을 미칩니다.
    
	예를 들어, 4바이트 데이터를 4바이트 경계에 맞추어 저장하면 CPU는 한 번에 데이터를 읽을 수 있지만, 정렬되지 않으면 여러 번 읽어야 할 수 있습니다.


22. **iOS 디바이스의 메모리 제약과 앱 메모리 제한에 대해 설명해주세요.**

    iOS 디바이스는 상대적으로 제한된 메모리를 가지고 있으며, 각 앱이 사용할 수 있는 메모리 양도 제한됩니다. 메모리 사용이 과도하면 앱이 비정상적으로 종료되거나 성능이 저하될 수 있습니다.
    
	- **앱 메모리 제한**: 앱은 운영체제가 할당한 메모리 범위 내에서만 동작할 수 있으며, 초과하면 **메모리 경고**가 발생하거나 앱이 종료될 수 있습니다.
	- **메모리 경고 처리**: iOS는 메모리가 부족할 때 앱에 메모리 경고를 보냅니다. 개발자는 메모리 경고를 처리하여 불필요한 메모리를 해제해야 합니다.

    22-1. 메모리 경고(Memory Warning)가 발생하면 어떤 조치를 취해야 하나요?
    
    메모리 경고가 발생하면 불필요한 리소스를 해제하여 메모리를 확보해야 합니다. 이를 통해 앱이 종료되지 않고 계속 실행될 수 있습니다.
    
	- **캐시 데이터 해제**: 캐시 데이터를 메모리에서 제거하여 메모리 공간을 확보합니다.
	- **사용하지 않는 객체 해제**: 메모리 경고가 발생했을 때 즉시 사용하지 않는 객체를 해제해야 합니다.
	- **이미지 등 큰 리소스 해제**: UI에서 사용하지 않는 이미지 또는 미디어 파일 등을 메모리에서 해제합니다.
	  
	iOS는 **`didReceiveMemoryWarning()`** 메서드를 통해 메모리 경고를 처리할 수 있도록 제공합니다.


23. **알고리즘의 시간 복잡도와 공간 복잡도의 개념, 그리고 빅오 표기법에 대해 설명해주세요.**

	- **시간 복잡도**: 알고리즘이 실행되는 데 걸리는 시간을 입력 크기와 관련지어 표현한 것입니다. 입력 크기(n)가 커질 때, 알고리즘의 실행 시간이 어떻게 증가하는지를 나타냅니다.
	- **공간 복잡도**: 알고리즘이 실행되는 동안 필요한 메모리 공간의 양을 입력 크기와 관련지어 표현한 것입니다.
	
	**빅오 표기법**은 시간 복잡도와 공간 복잡도를 수학적으로 표현하는 방법으로, 알고리즘의 성능을 분석할 때 사용됩니다. 입력 크기(n)가 커질 때, 알고리즘의 성능이 어떻게 변화하는지를 상한선으로 나타냅니다.

    23-1. O(n)과 O(log n)의 차이는 무엇인가요?
    
    - **O(n)**: 입력 크기(n)에 비례하여 실행 시간이 선형적으로 증가하는 알고리즘입니다. 예를 들어, 리스트에서 특정 요소를 찾는 선형 탐색(Linear Search)은 리스트 크기가 커질수록 탐색 시간이 비례하여 증가합니다.
	- **O(log n)**: 입력 크기가 n일 때, 알고리즘의 실행 시간이 로그 함수에 따라 증가하는 알고리즘입니다. 예를 들어, 이진 탐색(Binary Search)은 리스트가 두 개씩 나누어지면서 탐색 범위가 줄어들기 때문에 실행 시간이 입력 크기에 대해 매우 느리게 증가합니다.
    
	**O(log n)**는 일반적으로 **O(n)**보다 훨씬 빠르며, 큰 데이터셋에서 효율적인 알고리즘으로 평가됩니다.


24. **자주 사용되는 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)의 동작 원리와 시간 복잡도를 설명해주세요.**
    
    1) **퀵 정렬(Quick Sort)**
		- **동작 원리**: 퀵 정렬은 분할 정복 알고리즘으로, 배열에서 하나의 피벗(pivot)을 선택하고, 피벗을 기준으로 작은 값들은 왼쪽에, 큰 값들은 오른쪽에 배치한 후 재귀적으로 이 과정을 반복하여 정렬합니다.
		  
	    - **과정**:
	        1. 피벗을 선택합니다.
	        2. 피벗보다 작은 요소들은 피벗의 왼쪽으로, 큰 요소들은 오른쪽으로 분할합니다.
	        3. 각 부분 리스트에 대해 동일한 방법을 재귀적으로 적용합니다.
		- **시간 복잡도**:
		    - **평균 시간 복잡도**: O(n log n)
		    - **최악의 시간 복잡도**: O(n^2) (피벗이 항상 최악으로 선택될 경우)
		    - **공간 복잡도**: O(log n) (재귀 호출로 인한 스택 사용)
		      
	2) **병합 정렬(Merge Sort)**
		- **동작 원리**: 병합 정렬은 배열을 절반으로 나누어 재귀적으로 정렬한 후, 두 개의 정렬된 부분 배열을 병합하여 최종 정렬을 완성하는 알고리즘입니다.
		  
	    - **과정**:
	        1. 배열을 반으로 나눕니다.
	        2. 각 부분 배열을 재귀적으로 병합 정렬로 정렬합니다.
	        3. 두 부분 배열을 병합하여 하나의 정렬된 배열을 만듭니다.
		- **시간 복잡도**:
		    - **평균 및 최악의 시간 복잡도**: O(n log n)
		    - **공간 복잡도**: O(n) (추가 메모리 사용)

	3) **삽입 정렬(Insertion Sort)**
		- **동작 원리**: 배열을 순차적으로 탐색하며, 각 요소를 자신의 위치에 삽입하여 정렬합니다. 이미 정렬된 부분 배열에 새 요소를 삽입하는 방식으로 동작합니다.
		  
	    - **과정**:
	        1. 배열의 두 번째 요소부터 시작하여, 정렬된 부분 배열의 적절한 위치에 삽입합니다.
	        2. 이를 배열 끝까지 반복합니다.
		- **시간 복잡도**:
		    - **평균 및 최악의 시간 복잡도**: O(n^2)
		    - **공간 복잡도**: O(1) (추가 메모리 사용 없음)


25. **이진 탐색의 원리와 시간 복잡도에 대해 설명해주세요.**

	 - **동작 원리**: 이진 탐색은 **정렬된 배열**에서 특정 값을 찾는 방법으로, 중간 요소를 기준으로 탐색 범위를 절반으로 줄여가며 값을 찾습니다.
	   
    - **과정**:
        1. 배열의 중간 요소를 선택합니다.
        2. 찾는 값이 중간 값보다 작으면 왼쪽 부분 배열에서 탐색하고, 크면 오른쪽 부분 배열에서 탐색합니다.
        3. 이 과정을 값이 발견되거나 배열의 크기가 0이 될 때까지 반복합니다.
           
	- **시간 복잡도**: O(log n) (탐색 범위를 절반으로 줄이기 때문에 로그 시간 복잡도)
	- **전제 조건**: 이진 탐색은 **정렬된 배열**에서만 사용할 수 있습니다.


26. **동적 프로그래밍(Dynamic Programming)의 개념을 설명해주세요.**

	동적 프로그래밍(Dynamic Programming)은 문제를 작은 하위 문제들로 나누어 각각의 문제를 해결한 결과를 저장하고, 이를 활용하여 전체 문제를 해결하는 알고리즘 기법입니다. 재귀적 구조를 가지며, 중복 계산을 피하기 위해 결과를 저장하는 특징이 있습니다.
	
	- **메모이제이션(Memoization)**: 하위 문제의 결과를 **캐싱**하여 같은 하위 문제가 여러 번 호출될 때, 이전에 계산한 결과를 재사용하는 방식입니다. 주로 **탑다운(Top-Down)** 접근 방식에서 사용됩니다.
	  
	- **타뷸레이션(Tabulation)**: 작은 하위 문제부터 차례대로 계산하여, 최종 해결해야 할 문제까지 계산해 나가는 방식입니다. **바텀업(Bottom-Up)** 방식이라고도 합니다.    


27. **자료구조의 종류와 iOS 개발에서 자주 사용되는 자료구조에 대해 설명해주세요.**
    
    **자료구조의 주요 종류:**
    
	1. **배열(Array)**: 고정된 크기의 연속적인 메모리 공간에 데이터를 저장합니다. 빠른 인덱스 접근이 가능하지만, 크기가 고정되어 있는 점이 한계입니다.
	2. **연결 리스트(Linked List)**: 각 요소가 다음 요소에 대한 참조를 가지고 있는 자료구조입니다. 삽입과 삭제가 배열보다 효율적이지만, 인덱스 접근은 느립니다.
	3. **스택(Stack)**: **LIFO(Last In, First Out)** 방식으로 데이터를 관리합니다. 주로 함수 호출 스택이나 후위 표기법 계산 등에 사용됩니다.
	4. **큐(Queue)**: **FIFO(First In, First Out)** 방식으로 데이터를 처리합니다. 대기열이나 작업 처리에서 자주 사용됩니다.
	5. **해시 테이블(Hash Table)**: 키와 값의 쌍으로 데이터를 저장하며, 빠른 검색을 제공합니다.
	6. **트리(Tree)**: 계층 구조로 데이터를 저장하며, 이진 탐색 트리나 AVL 트리, 힙(Heap) 등이 포함됩니다.
	7. **그래프(Graph)**: 정점과 간선으로 이루어진 자료구조로, 네트워크, 경로 탐색 등에 사용됩니다.
	   
	**iOS 개발에서 자주 사용되는 자료구조:**
	
	- **배열(Array)**: Swift에서 가장 자주 사용하는 자료구조입니다. Swift의 `Array`는 가변적이며, 요소에 접근하는 데 O(1)의 시간 복잡도를 가집니다.
	- **딕셔너리(Dictionary)**: Swift에서 `Dictionary`는 해시 테이블을 기반으로 한 자료구조로, 키-값 쌍으로 데이터를 관리합니다.
	- **세트(Set)**: 중복되지 않는 요소들의 모음으로, 주로 고유한 값의 집합을 처리할 때 사용됩니다.
	- **스택(Stack)과 큐(Queue)**: Swift에서 스택과 큐는 `Array`를 사용해 간단히 구현할 수 있으며, iOS의 네비게이션 스택이나 비동기 작업 처리 등에 자주 활용됩니다.


28. **배열, 연결 리스트, 스택, 큐의 특징과 iOS에서의 구현 방법을 설명해주세요.**
    


29. **해시 테이블의 개념과 충돌 해결 방법을 설명해주세요.**

	해시 테이블은 **키-값 쌍**으로 데이터를 저장하는 자료구조로, 해시 함수(hash function)를 사용하여 키를 배열 인덱스로 변환해 빠르게 데이터를 검색할 수 있습니다. 주로 **O(1)**의 시간 복잡도를 가지며, 키에 대한 빠른 접근을 제공합니다.
	
	- **해시 함수**: 주어진 키를 해시 코드로 변환하여 배열의 인덱스를 계산하는 함수입니다. 해시 함수는 충돌을 최소화하는 것이 중요합니다.
	  
	**충돌 해결 방법:**
	
    - **체이닝(Chaining)**:
	    - 충돌이 발생한 인덱스에 링크드 리스트 또는 다른 자료구조를 사용하여 여러 개의 키-값 쌍을 저장합니다.
	    - 각 배열 요소가 리스트로 연결되어 있어 충돌 시 값을 해당 리스트에 추가합니다.
	    - 시간 복잡도는 최악의 경우 O(n)이 될 수 있습니다.
	      
	- **개방 주소법(Open Addressing)**:
	    - 충돌이 발생하면 해시 테이블 내 다른 빈 공간을 찾아 데이터를 저장합니다.
	    - 방법에는 **선형 탐사(Linear Probing)**, **제곱 탐사(Quadratic Probing)**, **이중 해싱(Double Hashing)** 등이 있습니다.
	        - **선형 탐사**: 충돌이 발생한 위치에서 순차적으로 다음 빈 공간을 찾습니다.
	        - **이중 해싱**: 두 개의 해시 함수를 사용해, 첫 번째 해시 함수에서 충돌이 발생하면 두 번째 해시 함수로 다른 위치를 찾습니다.


30. **암호화와 보안의 기본 개념, 그리고 iOS 앱 보안을 위한 방안에 대해 설명해주세요.**

	 **암호화와 보안의 기본 개념:**
	 
	- **암호화(Encryption)**: 데이터를 인가된 사용자만 읽을 수 있도록 변환하는 과정입니다. 암호화된 데이터를 복호화하기 위해서는 키가 필요합니다.
	  
	    - **대칭 키 암호화**: 암호화와 복호화에 같은 키를 사용하는 방식. 빠르지만, 키의 안전한 교환이 중요합니다.
	    - **비대칭 키 암호화**: 암호화와 복호화에 서로 다른 키(공개 키와 개인 키)를 사용하는 방식. 보안성이 높지만, 대칭 키에 비해 속도가 느립니다.
	      
	- **해싱(Hashing)**: 데이터를 고정된 크기의 해시 값으로 변환하는 방식입니다. 비밀번호 저장 시 주로 사용되며, 복호화가 불가능합니다.
	  
	 **iOS 앱 보안을 위한 방안: **
	 
	1. **앱 내 데이터 암호화**: 민감한 정보를 저장할 때는 암호화를 사용하여 데이터를 보호합니다. 예를 들어, **Keychain**을 사용하여 민감한 데이터를 안전하게 저장할 수 있습니다.

	2. **HTTPS 및 TLS 사용**: 네트워크 통신에서 HTTPS와 **TLS(Transport Layer Security)**를 사용하여 데이터를 암호화된 채널로 전송하여 보안을 강화합니다.
	    
	3. **앱 서명**: iOS 앱은 실행 전에 Apple이 서명한 코드로 검증되어 안전한 앱만 실행될 수 있도록 합니다.
	    
	4. **ATS(App Transport Security)**: iOS 9 이후, 애플은 ATS를 통해 기본적으로 앱이 HTTPS 연결을 사용하도록 강제하여 네트워크 보안을 향상시킵니다.
	    
	5. **기기 보안**: iOS는 **샌드박스 구조**를 사용해 앱 간의 데이터 접근을 제한하고, 앱마다 독립된 실행 환경을 제공합니다. 또 **Touch ID**나 **Face ID**를 활용해 보안 레벨을 높일 수 있습니다.


31. **가상 메모리(Virtual Memory)의 개념과 동작 원리에 대해 설명해주세요.**
    
    가상 메모리는 실제 물리 메모리(RAM)의 크기와 상관없이 컴퓨터가 더 큰 메모리 공간을 사용할 수 있도록 만드는 메커니즘입니다. 운영체제는 가상 주소를 실제 물리 메모리 주소로 매핑하여 프로세스가 실행되도록 관리합니다.
    
	 **동작 원리:**
	 
	1. **페이지(Page)**: 가상 메모리 공간은 일정 크기의 페이지로 나누어 관리됩니다. 각 페이지는 물리 메모리와 매핑되며, 가상 주소에서 물리 주소로 변환됩니다.
	    
	2. **페이지 테이블(Page Table)**: 각 프로세스는 페이지 테이블을 가지고 있으며, 이를 통해 가상 메모리 주소를 물리 메모리 주소로 변환합니다.
	    
	3. **페이지 교체(Page Replacement)**: 물리 메모리가 부족하면 사용하지 않는 페이지를 하드디스크(보조 기억 장치)에 저장하고, 필요한 페이지를 다시 로드하는 방식으로 관리합니다. 이 과정에서 **페이지 폴트(Page Fault)**가 발생할 수 있습니다.
	    
	 **장점:**
	- 메모리 사용의 효율성 증가: 메모리를 동적으로 할당할 수 있습니다.
	- 큰 프로그램을 실행할 수 있음: 물리 메모리보다 더 큰 프로그램도 실행할 수 있습니다.


32. **데이터베이스의 종류와 iOS에서 주로 사용되는 데이터베이스에 대해 설명해주세요.**
    
    **데이터베이스의 종류:**
    
	- **관계형 데이터베이스(RDBMS)**: 데이터를 테이블 형식으로 저장하며, SQL을 통해 데이터를 관리합니다. 예: MySQL, PostgreSQL.
    
	- **NoSQL 데이터베이스**: 데이터가 테이블이 아닌 비정형 데이터로 저장되며, 주로 JSON 형식으로 저장됩니다. 예: MongoDB, Couchbase.
    
	**iOS에서 주로 사용되는 데이터베이스:**

	1. **SQLite**: iOS에서 기본적으로 지원하는 관계형 데이터베이스입니다. 가벼운 무게와 빠른 속도 덕분에 모바일 애플리케이션에서 널리 사용됩니다.
	    
	2. **Core Data**: iOS에서 객체 그래프 관리와 영속성을 제공하는 프레임워크로, 데이터베이스뿐 아니라 객체 관계 모델링까지 처리할 수 있습니다.
	    
	3. **Realm**: 모바일 데이터베이스로 빠른 성능과 사용 편의성을 제공하여, 최근 많은 iOS 앱에서 사용됩니다.


33. **싱글톤 패턴(Singleton Pattern)이란 무엇이며, 어떤 경우에 사용하나요?**
    
    **싱글톤 패턴**은 클래스의 인스턴스를 **오직 하나만** 생성하여, 해당 인스턴스를 어디서든지 접근할 수 있도록 보장하는 디자인 패턴입니다.
    
	- **애플리케이션 내 전역 상태 관리**: 앱 설정이나 공통 데이터 관리.
	- **네트워크 매니저**: 네트워크 요청을 하나의 공통된 객체를 통해 관리.
	- **데이터베이스 연결**: 하나의 데이터베이스 연결 객체를 전역적으로 사용해야 할 때.
	  
	**장점:**
	
	- 전역적으로 접근할 수 있는 객체가 필요할 때 사용.
	- 메모리 낭비를 방지하고, 인스턴스가 하나임을 보장하여 관리가 용이.


34. **Swift에서 싱글톤 패턴을 구현할 때 멀티스레드에 대해서 어떻게 고려해야 하나요?**
    
	Swift에서 싱글톤 패턴을 구현할 때는 **멀티스레드 환경에서 안전**하도록 고려해야 합니다. 싱글톤 객체가 여러 스레드에서 동시에 생성되는 문제를 방지하려면 **스레드 안전성**이 중요합니다.
	
	 **`static let`로 구현**: Swift의 `static let`을 사용하면 스레드 안전성을 보장하며, 런타임에 단 한 번만 초기화됩니다.


35. **Array와 List의 차이점이 무엇인지 설명해주세요.**
    
	 **배열(Array)**:
	- **연속된 메모리 공간**에 데이터를 저장하며, **인덱스를 통한 빠른 접근**(O(1))이 가능합니다.
	- **크기가 고정**되며, 요소의 추가나 삭제가 발생하면 새로운 배열을 만들어야 하므로 성능에 영향을 줄 수 있습니다.
	
	 **리스트(List)**:
	- 각 요소가 다음 요소에 대한 참조를 포함하는 **동적 자료구조**입니다. 삽입과 삭제는 **빠르지만**(O(1)), 특정 인덱스에 접근할 때는 **느립니다**(O(n)).
	- 크기가 동적으로 변하며, 메모리 사용의 유연성이 큽니다.


질문구성: https://github.com/JeaSungLEE/iOSInterviewquestions
