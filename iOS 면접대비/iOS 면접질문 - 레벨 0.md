작성일시: 24.10.21 (Mon)

1. **컴퓨터 시스템에서 CPU, RAM, 저장 장치의 역할과 이들이 어떻게 상호 작용하는지 설명해주세요.**

	- **CPU(중앙 처리 장치)**: CPU는 컴퓨터의 두뇌에 해당합니다. 명령어를 해석하고 실행하며, 연산과 제어를 담당합니다. 프로그램 실행, 산술 및 논리 연산, 제어 신호 전송 등 다양한 기능을 수행합니다.
	- **RAM(메인 메모리)**: RAM은 데이터를 일시적으로 저장하는 장치로, CPU가 현재 처리 중인 데이터를 빠르게 읽고 쓸 수 있도록 합니다. RAM에 저장된 데이터는 휘발성이 있어 전원이 꺼지면 사라집니다.
	- **저장 장치(하드 드라이브, SSD)**: 하드 드라이브나 SSD는 데이터를 영구적으로 저장하는 장치입니다. 운영체제, 프로그램, 파일들이 저장되며, 필요할 때 RAM으로 데이터를 불러와 CPU에서 처리할 수 있게 합니다.
	  
	**상호작용**: 
	CPU는 저장 장치에 직접적으로 접근하지 않고, 우선적으로 RAM에서 데이터를 가져옵니다. 프로그램을 실행하면, 저장 장치에 저장된 프로그램의 데이터가 RAM으로 로드되고, CPU가 이 데이터를 처리합니다. 만약 필요한 데이터가 RAM에 없으면 저장 장치에서 다시 가져오는 과정을 거칩니다.

	1-1. CPU와 메모리 간의 데이터 교환은 어떻게 이루어지나요?
	1-2. 버스(Bus)란 무엇이며, 어떤 종류가 있나요?
	
	CPU는 메모리(RAM)와 **버스(bus)** 를 통해 데이터를 교환합니다. 
	이때 버스는 CPU와 메모리 또는 다른 장치 간의 데이터 전달 경로입니다.
	
	- 주소 버스(address bus): CPU가 메모리의 특정 위치에 접근하기 위한 주소 정보를 전달합니다.
	- 데이터 버스(data bus): CPU와 메모리 간에 실제 데이터를 주고받는 역할을 합니다.
	- 제어 버스(control bus): 데이터 전송을 제어하는 신호를 보내고, 데이터의 읽기/쓰기와 같은 동작을 조절합니다.

  
2. **캐시 메모리의 개념과 역할에 대해 설명해주세요.**
   
	캐시 메모리(cache memory)는 CPU와 메인 메모리(RAM) 사이에 위치하여, CPU가 자주 사용하는 데이터를 빠르게 접근할 수 있도록 하는 고속 메모리입니다. RAM보다 훨씬 빠른 속도를 제공하며, CPU의 작업 효율을 높여줍니다. CPU는 데이터 접근 시 우선적으로 캐시에서 데이터를 찾고, 없으면 RAM에서 데이터를 가져옵니다.

    2-1. 캐시의 지역성(Locality) 원리에 대해 설명해주세요.
    
    - **시간적 지역성(Temporal Locality)**: 최근에 접근한 데이터는 다시 접근할 가능성이 높다는 원리입니다. 따라서 자주 사용된 데이터는 캐시에 저장됩니다.
    - **공간적 지역성(Spatial Locality)**: 특정 데이터에 접근한 후 그 주변 데이터도 접근할 가능성이 높다는 원리입니다. 즉, 인접한 메모리 영역이 캐시에 함께 로드됩니다.


3.  **CPU 아키텍처의 종류(예: ARM, x86)와 각 특징에 대해 설명해주세요.**
   
	ARM: ARM(Advanced RISC Machine)은 저전력 소모와 효율성을 중시하는 RISC(간소화 명령어 집합 컴퓨터) 아키텍처입니다. 주로 모바일 기기, 임베디드 시스템에 사용되며, 배터리 효율성이 중요합니다.
	
	x86: x86은 인텔에서 개발한 CISC(복잡 명령어 집합 컴퓨터) 아키텍처입니다. 복잡한 명령어를 처리할 수 있으며, 주로 데스크탑이나 서버 컴퓨터에 사용됩니다.
   

4.  **iOS 기기에서 사용되는 AP(Application Processor)의 특징과 역할에 대해 설명해주세요.**

	AP(Application Processor)는 스마트폰과 같은 모바일 장치에서 CPU, GPU, 메모리 제어기 등을 통합한 핵심 프로세서입니다. iOS 기기에서 AP는 iPhone의 모든 연산, 그래픽 처리, 그리고 센서 제어까지 담당합니다. Apple의 AP, 예를 들어 A 시리즈 칩(A14, A15 등)은 ARM 기반의 아키텍처를 사용하며, iOS의 성능을 최적화하기 위해 특별히 설계되었습니다.

	4-1. SoC(System on a Chip)의 개념은 무엇인가요?
	
	SoC(System on a Chip)는 CPU, GPU, 메모리, 무선 통신 모듈, 그리고 기타 컴퓨팅 구성 요소들을 하나의 칩에 통합한 것입니다. SoC는 작은 크기와 효율성을 바탕으로 스마트폰, 태블릿 등 모바일 장치에서 사용됩니다. 하나의 칩에 여러 기능을 집약하여 전력 소모를 줄이고, 공간을 절약합니다.


5.  **운영체제의 역할과 iOS의 운영체제 구조에 대해 설명해주세요.**
   
	운영체제(OS)는 하드웨어 자원을 관리하고, 사용자와 소프트웨어 간의 인터페이스를 제공합니다. 주요 기능은 프로세스 관리, 메모리 관리, 파일 시스템 관리, 디바이스 제어 등입니다.
	
	iOS는 Apple의 모바일 운영체제이며, Darwin 커널을 기반으로 합니다. iOS는 다음과 같은 계층 구조를 가집니다:
	
	- Core OS: 커널과 기본 시스템 서비스, 보안, 파일 시스템 관리.
	- Core Services: 네트워크, 위치 서비스, 데이터 관리 등 핵심 서비스 제공.
	- Media Layer: 그래픽, 오디오, 비디오 처리 기능 제공.
	- Cocoa Touch: iOS 앱을 위한 UI 및 이벤트 처리 계층.

    5-1. iOS의 샌드박스 구조는 어떻게 동작하나요?
    
    iOS는 샌드박스 구조를 통해 각 앱이 독립된 환경에서 실행되도록 하여 보안을 강화합니다. 앱은 다른 앱의 데이터를 접근할 수 없으며, 운영체제가 허용하는 자원만 사용할 수 있습니다. 이로 인해 악성 앱이 시스템 전체에 영향을 미치는 것을 방지합니다.

    5-2. 커널(Kernel)의 역할은 무엇인가요?
    
    커널은 운영체제의 핵심 부분으로, 하드웨어와 소프트웨어 간의 상호작용을 관리합니다. 메모리 관리, 프로세스 제어, 하드웨어 장치 제어, 파일 시스템 관리 등의 기능을 제공합니다.

    5-3. 다중 태스킹(Multitasking)은 어떻게 지원되나요?
    
    iOS는 다중 태스킹을 지원하여 여러 앱이 동시에 실행될 수 있도록 합니다. iOS에서는 백그라운드에서 실행되는 앱을 관리하고, 앱이 자원을 효율적으로 사용할 수 있도록 백그라운드 작업을 제어합니다. 백그라운드 모드, 푸시 알림, 백그라운드 작업 업데이트 등이 다중 태스킹을 지원하는 주요 기능입니다.


6.  **프로세스와 스레드의 차이점, 그리고 iOS에서의 프로세스와 스레드 관리 방법에 대해 설명해주세요.**

	프로세스: 프로세스는 실행 중인 프로그램을 의미하며, 독립된 메모리 공간을 가지고 CPU, 메모리, 파일 등을 사용하는 하나의 작업 단위입니다. 각 프로세스는 자체 주소 공간을 가지며, 다른 프로세스와 메모리 공간을 공유하지 않습니다. 프로세스 간의 통신은 복잡하며, 주로 IPC(Inter-Process Communication)를 통해 이루어집니다.
	
	스레드: 스레드는 프로세스 내에서 실행되는 작업의 작은 단위입니다. 하나의 프로세스는 여러 스레드를 가질 수 있으며, 이들은 프로세스 내에서 메모리와 자원을 공유합니다. 스레드 간의 통신은 상대적으로 빠르고 간단하지만, 자원 공유로 인해 동기화 문제가 발생할 수 있습니다.
	
	**iOS에서의 관리:**
	
	iOS에서는 프로세스가 앱 단위로 관리됩니다. 각 앱은 독립된 프로세스로 실행되며, 샌드박스 환경에서 실행되어 다른 앱의 프로세스와 격리됩니다.
	스레드는 주로 Grand Central Dispatch(GCD) 또는 NSOperation을 통해 관리되며, 멀티스레딩을 효율적으로 처리할 수 있도록 도와줍니다.

    6-1. 멀티스레딩이 필요한 이유는 무엇인가요?
    
	멀티스레딩은 여러 작업을 동시에 처리할 수 있도록 하는 기술입니다. 이를 통해 CPU 자원을 보다 효율적으로 사용하며, 다음과 같은 이점이 있습니다:
	
	- **병렬 처리**: 멀티코어 CPU에서 작업을 병렬로 처리하여 성능을 극대화할 수 있습니다.
	- **UI 반응성 개선**: 네트워크 요청이나 파일 입출력 같은 시간이 오래 걸리는 작업을 별도의 스레드에서 처리하여 UI가 멈추지 않도록 할 수 있습니다.
	- **리소스 활용**: 여러 스레드를 사용하면 대기 시간이 긴 작업을 비동기적으로 처리하여 시스템 리소스를 효율적으로 사용할 수 있습니다.

    6-2. iOS에서 GCD(Grand Central Dispatch)는 어떤 역할을 하나요?
    
	GCD는 iOS에서 멀티스레딩을 쉽게 관리할 수 있도록 제공되는 라이브러리입니다. GCD는 작업을 큐(queue)에 넣고, 운영체제가 적절한 스레드에서 해당 작업을 실행하도록 합니다. 주요 역할은 다음과 같습니다:
	
	- **동시성 처리**: GCD는 여러 작업을 동시에 처리하는 동시성(concurrency)을 지원합니다.
	- **비동기 작업 처리**: 네트워크 요청, 파일 입출력, UI 업데이트 등을 비동기적으로 처리할 수 있어, 메인 스레드에서 작업을 처리하는 동안 UI가 멈추지 않도록 도와줍니다.
	- **스레드 풀 관리**: 개발자가 직접 스레드를 생성하거나 관리할 필요 없이, GCD가 스레드를 효율적으로 할당하고 관리합니다.


7. **메모리 관리 기법 중 iOS에서 사용되는 방식과 그 특징에 대해 설명해주세요.**
   
	iOS는 자동 참조 카운팅(ARC, Automatic Reference Counting)을 사용하여 메모리를 관리합니다. ARC는 컴파일러가 객체의 메모리 관리를 자동으로 수행하여, 개발자가 명시적으로 메모리 할당과 해제를 할 필요가 없습니다.

    7-1. 자동 참조 카운팅(ARC)은 어떻게 동작하나요?
    
    ARC는 객체의 참조 카운트(reference count)를 추적하여, 더 이상 참조되지 않는 객체의 메모리를 자동으로 해제합니다. 객체를 참조할 때마다 참조 카운트가 증가하고, 참조가 없어질 때마다 카운트가 감소합니다. 참조 카운트가 0이 되면 해당 객체의 메모리가 해제됩니다.
    
	- **강한 참조(strong reference)**: 객체의 참조 카운트를 증가시키는 참조입니다.
	- **약한 참조(weak reference)**: 객체의 참조 카운트를 증가시키지 않으며, 참조하는 객체가 해제되면 `nil`로 설정됩니다.

    7-2. Garbage Collection과의 차이는 무엇인가요?
    
    - **ARC**는 컴파일 타임에 객체의 수명 주기를 결정하며, 참조 카운트를 기반으로 메모리를 관리합니다.
	- **Garbage Collection**은 런타임에 주기적으로 메모리를 검사하여, 더 이상 참조되지 않는 객체를 해제합니다. 이는 메모리 해제를 즉각적으로 하지 않기 때문에 성능에 영향을 미칠 수 있습니다.
  
  
8. **iOS의 샌드박스(Sandbox) 개념과 역할, 그리고 앱 간 데이터 공유 방법에 대해 설명해주세요.**

    iOS는 **샌드박스**를 통해 각 앱이 독립된 환경에서 실행되도록 하여 보안을 강화합니다. 앱은 자신의 파일 시스템에만 접근할 수 있고, 다른 앱이나 시스템 자원에 접근할 수 없습니다. 이러한 구조는 악성 코드가 시스템이나 다른 앱에 영향을 미치는 것을 방지합니다.

    8-1. URL 스킴(URL Scheme)을 이용한 앱 간 통신은 어떻게 이루어지나요?
    
    iOS 앱 간 통신은 주로 URL 스킴을 통해 이루어집니다. URL 스킴은 하나의 앱이 다른 앱을 열어 특정 작업을 수행하게 하는 방식입니다. 예를 들어, 한 앱에서 URL 스킴을 통해 다른 앱을 호출하고 데이터를 전달할 수 있습니다.

    8-2. 앱 그룹(App Group)을 활용하여 데이터 공유를 하는 방법은 무엇인가요?
    
    **앱 그룹**은 여러 앱이 동일한 그룹에 속할 때 데이터를 공유할 수 있는 방법입니다. 앱 그룹을 사용하면 앱 간에 파일, 사용자 설정 등을 공유할 수 있습니다. 이를 위해 **UserDefaults**나 **파일 시스템**을 활용하여 데이터를 저장하고 읽을 수 있습니다.


9. **iOS에서의 메모리 구조와 관리 방식에 대해 자세히 설명해주세요.**
   
    iOS는 **스택(Stack)** 과 **힙(Heap)** 을 포함하는 메모리 구조를 관리합니다.
    
	- **스택(Stack)**: 함수 호출, 지역 변수 등을 저장하는 메모리 공간입니다. 스택은 메모리를 정적으로 할당하며, LIFO(Last In, First Out) 방식으로 관리됩니다. 스택은 크기가 작고 매우 빠르지만, 한정된 메모리를 사용할 수 있습니다.
    
	- **힙(Heap)**: 동적으로 할당된 메모리를 저장하는 공간입니다. 객체나 배열과 같은 동적 데이터는 힙에 할당되며, 개발자가 수동으로 할당과 해제를 관리할 필요가 있습니다. 힙은 더 큰 메모리 공간을 제공하지만, 할당 및 해제 작업이 상대적으로 느립니다.

	9-1. 힙(Heap)과 스택(Stack)의 차이점은 무엇인가요?
	
    -  **메모리 할당 방식**: 스택은 정적 메모리 할당, 힙은 동적 메모리 할당을 사용합니다.
	- **속도**: 스택은 메모리 할당과 해제가 매우 빠릅니다. 반면 힙은 동적 할당과 해제가 필요하므로 상대적으로 느립니다.
	- **메모리 크기**: 스택은 크기가 제한되어 있지만, 힙은 매우 큰 메모리 영역을 사용할 수 있습니다.
	- **관리 방식**: 스택은 운영체제가 자동으로 관리하고, 힙은 개발자가 관리해야 합니다.

  
10. **네트워크 프로토콜 스택과 iOS에서의 네트워크 통신 방식에 대해 설명해주세요.**

	네트워크 프로토콜 스택은 네트워크 통신이 이루어지는 계층 구조로, 각 계층이 특정한 역할을 담당합니다. **iOS**는 네트워크 통신을 위해 TCP/IP 스택을 사용하며, 다양한 네트워크 프로토콜을 지원합니다. iOS에서의 네트워크 통신 방식은 주로 **NSURLSession**을 활용하여 HTTP/HTTPS를 통해 데이터를 송수신합니다.

	 **iOS에서의 네트워크 통신 방식:**
	
	- **NSURLSession**: iOS에서 네트워크 요청을 관리하는 기본 클래스입니다. HTTP/HTTPS 요청을 비동기적으로 처리하며, 파일 다운로드, 데이터 업로드, API 호출 등을 지원합니다.
	- **WebSocket**: 실시간 양방향 통신을 위해 iOS에서는 WebSocket을 사용할 수 있습니다. 실시간 데이터를 빠르게 전송할 수 있는 웹 표준입니다.
	- **TCP/UDP**: iOS에서도 TCP와 UDP 기반의 소켓 통신을 지원하며, 낮은 수준의 네트워크 프로그래밍이 가능합니다. 이 경우 **CFNetwork** 또는 **BSD 소켓**을 사용합니다    


11. **HTTP와 HTTPS의 차이점, 그리고 iOS에서의 보안 통신 방법에 대해 설명해주세요.**
	
	- **HTTP (HyperText Transfer Protocol)**: 인터넷 상에서 데이터를 주고받는 표준 프로토콜로, 텍스트 기반의 통신입니다. HTTP는 보안이 설정되어 있지 않기 때문에 데이터가 평문으로 전송되며, 공격자에 의해 쉽게 가로챌 수 있습니다.
	  
	- **HTTPS (HyperText Transfer Protocol Secure)**: HTTP에 보안 계층(SSL/TLS)이 추가된 프로토콜입니다. HTTPS는 데이터를 암호화하여 전송하므로, 제3자가 데이터를 도청하거나 변조할 수 없습니다. HTTPS는 기본적으로 SSL/TLS를 사용해 보안성을 보장합니다.
	  
	**iOS에서의 보안 통신 방법:**
	   
	iOS에서 보안 통신을 구현하는 방법은 **HTTPS**를 사용하는 것입니다. Apple은 앱에서 HTTPS 통신을 권장하며, **ATS(App Transport Security)**를 통해 앱이 안전한 통신 방법을 따르도록 강제하고 있습니다. ATS는 iOS 9 이후로 기본 설정으로 적용되며, 기본적으로 SSL/TLS 암호화된 통신을 요구합니다    

    11-1. SSL/TLS의 동작 원리는 무엇인가요?
    
    SSL/TLS는 클라이언트와 서버 간의 통신을 암호화하여 보안성을 제공하는 프로토콜입니다.
    
	- **핸드셰이크 과정**: 클라이언트와 서버가 통신하기 전에 암호화 방식과 세션 키를 설정하는 과정입니다.
	    1. **클라이언트 헬로(Client Hello)**: 클라이언트가 서버에 암호화 알고리즘 목록과 TLS 버전을 제시합니다.
	    2. **서버 헬로(Server Hello)**: 서버는 그 목록에서 사용할 암호화 알고리즘과 서버의 인증서(공개 키 포함)를 클라이언트에 전달합니다.
	    3. **인증서 검증**: 클라이언트는 서버 인증서를 확인하고 신뢰할 수 있는 인증 기관에서 발급된 것인지 확인합니다.
	    4. **세션 키 생성**: 클라이언트와 서버는 대칭 키 암호화를 위해 세션 키를 교환합니다.
	    5. **암호화된 통신 시작**: 양쪽은 세션 키를 사용해 암호화된 데이터 통신을 진행합니다.


12. **컴퓨터 네트워킹에서 OSI 7계층 모델에 대해 설명해주세요.**
    
	**OSI(Open Systems Interconnection) 모델**은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 통신 과정에서 담당하는 역할을 분리하여 설명하는 모델입니다.

    12-1. 각 계층의 역할과 프로토콜은 무엇인가요?
    
	1. **물리 계층(Physical Layer)**: 데이터 전송을 위한 물리적인 하드웨어 장치와 매체를 정의합니다. 전기 신호, 빛, 전송 케이블 등이 포함됩니다.
	    - **프로토콜**: 이더넷, RS-232 등.
	      
	2. **데이터 링크 계층(Data Link Layer)**: 물리 계층에서 오류 없이 데이터가 전송되도록 하며, MAC 주소를 사용하여 장치 간의 통신을 관리합니다.
	    - **프로토콜**: 이더넷, PPP, HDLC, ARP 등.
	      
	3. **네트워크 계층(Network Layer)**: 데이터를 목적지까지 전달하기 위한 경로를 결정합니다. IP 주소를 사용하여 라우팅을 관리합니다.
	    - **프로토콜**: IP(IPv4, IPv6), ICMP, IGMP 등.
	      
	4. **전송 계층(Transport Layer)**: 송신자와 수신자 간에 신뢰성 있는 데이터 전송을 제공합니다. 포트를 사용하여 여러 애플리케이션 간의 데이터 전송을 구분합니다.
	    - **프로토콜**: TCP, UDP 등.
	      
	5. **세션 계층(Session Layer)**: 송수신 간의 대화(세션)를 설정하고, 유지하며, 종료합니다. 세션 중에 발생할 수 있는 통신 오류를 처리합니다.
	    - **프로토콜**: NetBIOS, PPTP 등.
	      
	6. **표현 계층(Presentation Layer)**: 데이터를 응용 계층에서 사용할 수 있도록 변환하며, 암호화 및 압축을 수행합니다.
	    - **프로토콜**: SSL, TLS, JPEG, GIF 등.
	      
	7. **응용 계층(Application Layer)**: 사용자와 직접 상호작용하는 인터페이스를 제공합니다. 웹 브라우저, 이메일 등 애플리케이션 프로그램이 이 계층에서 동작합니다.
		- **프로토콜**: HTTP, FTP, SMTP, DNS 등.

    12-2. TCP/IP 모델과 OSI 모델의 차이점은 무엇인가요?
    
    **TCP/IP 모델**은 OSI 모델과 달리 4계층 구조로 간단하게 통신 프로토콜을 설명합니다. 실질적으로 오늘날 인터넷에서 사용하는 프로토콜 모델입니다.
	- **TCP/IP 모델의 4계층**:
	    1. **네트워크 인터페이스 계층**: 물리 계층과 데이터 링크 계층에 해당하는 부분으로, 네트워크 하드웨어와 연결된 물리적 데이터 전송을 담당합니다.
	    2. **인터넷 계층**: IP 주소를 기반으로 한 네트워크 계층입니다. 라우팅 및 데이터 패킷 전달을 담당합니다.
	    3. **전송 계층**: TCP/UDP를 사용해 신뢰성 있는 데이터 전송을 담당합니다.
	    4. **응용 계층**: 웹, 이메일, 파일 전송 등 사용자 인터페이스와 직접 연결된 응용 계층입니다.
	
	**차이점**:
	- OSI 모델은 7계층으로 나누어 더 구체적이며, 계층별로 명확한 구분이 있습니다.
	- TCP/IP 모델은 실무에 더 적합하게 만들어졌으며, 4계층으로 간단하게 구성되어 있습니다. OSI 모델은 이론적이고, TCP/IP 모델은 실제 네트워크 통신에 더 많이 사용됩니다.

  
13. **HTTP 프로토콜의 특징과 HTTP/1.1과 HTTP/2의 차이점을 설명해주세요.**

    HTTP 프로토콜의 특징:
	- **무상태성(Stateless)**: HTTP는 무상태 프로토콜입니다. 즉, 서버는 클라이언트의 이전 요청에 대한 상태를 기억하지 않습니다. 각 요청은 독립적으로 처리되며, 새로운 연결이 이루어질 때마다 서버는 클라이언트의 상태를 다시 파악해야 합니다.
	- **텍스트 기반**: HTTP는 인간이 읽을 수 있는 텍스트 기반 프로토콜로, 클라이언트와 서버 간의 요청과 응답은 텍스트로 이루어집니다.
	- **애플리케이션 계층 프로토콜**: HTTP는 OSI 모델의 애플리케이션 계층에 속하며, 주로 웹 브라우저와 서버 간의 통신을 담당합니다.

    13-1. HTTP의 무상태(Stateless) 성질은 무엇이며, 어떻게 극복하나요?
    
    HTTP는 무상태이므로 클라이언트와 서버 간의 요청이 독립적으로 처리되어 이전의 요청 상태를 유지하지 않습니다. 이를 극복하기 위해 다음과 같은 방법이 사용됩니다:
    
	- **쿠키(Cookies)**: 서버가 클라이언트의 상태를 기억하기 위해 클라이언트 측에 작은 데이터를 저장합니다.
	- **세션(Session)**: 서버 측에서 클라이언트의 상태를 기억하고 세션 ID를 통해 클라이언트를 식별합니다.
	- **JWT(JSON Web Token)**: 상태를 클라이언트 측에서 유지하기 위해, 서버는 JWT를 발급하여 클라이언트가 이를 전달함으로써 상태를 유지합니다.

    13-2. HTTP/2에서 추가된 주요 기능은 무엇인가요?
    
    HTTP/1.1과 HTTP/2의 차이점:
	- **HTTP/1.1**: 클라이언트와 서버는 요청마다 새로운 연결을 열고 닫습니다. **Keep-Alive**가 적용되었지만, 여전히 하나의 연결에서 하나의 요청만 처리할 수 있어 비효율적입니다.
	- **HTTP/2**: 성능을 개선하기 위해 여러 기능이 추가되었습니다.
	    - **멀티플렉싱(Multiplexing)**: 하나의 TCP 연결에서 여러 요청과 응답을 동시에 처리할 수 있습니다. 이를 통해 HTTP/1.1의 문제인 '헤드 오브 라인 블로킹'을 해결했습니다.
	    - **헤더 압축**: 요청과 응답 헤더를 압축하여 네트워크 대역폭을 절약하고, 성능을 향상시킵니다.
	    - **서버 푸시(Server Push)**: 서버는 클라이언트가 요청하지 않은 리소스를 미리 전송할 수 있습니다. 이를 통해 필요한 리소스를 클라이언트가 빠르게 받을 수 있습니다.

    13-3. HTTP/3에서 추가된 기능은 무엇인가요?
    
    - **HTTP/3**는 기존의 TCP 대신 **QUIC**(Quick UDP Internet Connections)를 기반으로 합니다.
    - **QUIC 프로토콜**: UDP를 기반으로 하지만 TCP의 신뢰성 있는 연결 성질을 추가하여 성능을 개선합니다.
    - **0-RTT 연결**: 첫 번째 요청 시점부터 데이터를 전송할 수 있어 연결 성립 속도를 크게 줄입니다.
    - **헤드 오브 라인 블로킹 제거**: TCP의 문제점인 '헤드 오브 라인 블로킹'을 완전히 제거하였으며, 개별 스트림에서의 손실만 재전송이 발생합니다.


14. **TCP와 UDP의 특징과 차이점에 대해 설명해주세요.**
    
    TCP와 UDP의 특징: 
	- **TCP(Transmission Control Protocol)**:
	    - 연결 지향형 프로토콜입니다. 통신을 시작하기 전에 송신자와 수신자가 연결을 설정(3-way handshake)해야 합니다.
	    - 데이터 전송의 신뢰성을 보장하며, 데이터가 손실되면 재전송합니다.
	    - 데이터의 순서가 보장되며, 패킷이 순서대로 도착하지 않으면 재조합하여 처리합니다.
	    - 오류 검출 및 수정 기능이 있어 안정적인 통신을 보장합니다.
	      
	- **UDP(User Datagram Protocol)**:
	    - 비연결 지향형 프로토콜입니다. 송신자와 수신자는 연결을 설정하지 않고, 데이터를 전송합니다.
	    - 신뢰성이 없으며, 데이터가 손실되거나 순서가 틀리더라도 재전송을 하지 않습니다.
	    - 매우 간단하고 빠르며, 오버헤드가 적습니다.
	    - 데이터 전송의 순서가 보장되지 않으며, 오류 검출이 불완전합니다.

	14-1. 연결 지향형 프로토콜과 비연결 지향형 프로토콜은 무엇인가요?
	
	- **연결 지향형 프로토콜**: 송신자와 수신자가 먼저 연결을 설정한 후 데이터를 주고받는 방식입니다. 연결을 유지하면서 데이터 전송을 보장합니다. TCP가 이에 해당합니다.
	- **비연결 지향형 프로토콜**: 연결을 설정하지 않고 데이터를 전송하며, 패킷을 받는 즉시 처리합니다. 데이터 전송의 신뢰성은 없지만 빠른 전송 속도를 제공합니다. UDP가 이에 해당합니다.

	14-2. TCP의 3-way handshake 과정은 어떻게 이루어지나요?
	
	TCP는 신뢰성 있는 연결을 설정하기 위해 **3-way handshake**를 사용합니다.
	
	1. **SYN**: 클라이언트가 서버에 연결을 요청하는 메시지(SYN)를 보냅니다.
	2. **SYN-ACK**: 서버는 요청을 수락한다는 의미로 SYN과 ACK 메시지를 클라이언트에 보냅니다.
	3. **ACK**: 클라이언트는 서버의 응답을 확인했다는 ACK 메시지를 보냅니다. 이로써 연결이 성립됩니다.

	14-3.  어떤 상황에서 UDP를 사용하는 것이 적합한가요?
	
	UDP는 빠른 전송이 중요하지만, 데이터의 신뢰성보다는 속도가 우선시되는 경우에 적합합니다.
	
	- **스트리밍 서비스**: 비디오 또는 오디오 스트리밍에서는 약간의 데이터 손실이 있어도 큰 문제가 없으며, 실시간 전송이 중요합니다.
	- **온라인 게임**: 빠른 반응이 필요한 게임에서는 약간의 데이터 손실보다 속도가 중요합니다.
	- **VoIP(Voice over IP)**: 실시간 음성 통신에서도 빠른 데이터 전송이 중요하며, 데이터 손실이 발생하더라도 속도가 우선됩니다.


15. **소켓 통신에 대해 설명해주세요.**

    **소켓 통신**은 네트워크 상에서 두 컴퓨터 간에 데이터를 주고받기 위해 사용하는 양방향 통신 방식입니다. 소켓은 IP 주소와 포트 번호를 사용하여 클라이언트와 서버 간의 연결을 설정하고 데이터를 주고받습니다. 소켓은 전송 계층에서 사용되며, 주로 **TCP** 또는 **UDP** 프로토콜을 기반으로 동작합니다.


16. **REST API와 iOS에서의 네트워크 요청 및 응답 처리 방법에 대해 설명해주세요.**

    REST API란?
    
	**REST(Representational State Transfer)** API는 클라이언트와 서버 간의 통신을 위해 HTTP 프로토콜을 기반으로 하는 아키텍처 스타일입니다. REST는 리소스를 URI로 표현하며, 리소스에 대한 CRUD(Create, Read, Update, Delete) 작업을 HTTP 메서드(POST, GET, PUT, DELETE)로 정의합니다.
	
	REST API는 무상태(stateless)이며, 각 요청은 독립적이고, 필요한 모든 정보를 포함합니다. 이를 통해 클라이언트는 서버에서 데이터를 요청하고, 서버는 응답을 통해 데이터를 반환합니다.
	
	 iOS에서 REST API를 사용하는 방법:
	 
	iOS에서는 **`URLSession`** 클래스를 사용하여 네트워크 요청을 보내고 응답을 처리합니다. `URLSession`은 비동기적인 HTTP 요청을 처리하며, 데이터를 서버로 전송하거나 서버에서 데이터를 수신하는 데 사용됩니다.
    

    16-1. iOS에서 `URLSession`을 사용하여 네트워크 요청을 보내는 방법은 무엇인가요?


17. **REST API에서 HTTP 메서드들의 차이점을 설명해주세요.**

    
    

    17-1. `GET`과 `POST`의 차이점은 무엇인가요?


18. **HTTP 상태 코드에 대해서 설명해주세요.**

    
    


19. **iOS에서 이미지 파일 포맷(PNG, JPEG 등)과 각 포맷의 특징에 대해 설명해주세요.**

    
    

    19-1.  PNG와 JPEG의 차이점은 무엇인가요?
    


20. **PNG 파일이 어떻게 저장되고 구성되는지 설명해주세요.**
    
    


21. **iOS에서 메모리 사이즈와 관련된 개념과 고려 사항에 대해 설명해주세요.**

    
    

    21-1.메모리 정렬(Alignment)이 성능에 미치는 영향은 무엇인가요?
      


22. **iOS 디바이스의 메모리 제약과 앱 메모리 제한에 대해 설명해주세요.**

    
    

    22-1. 메모리 경고(Memory Warning)가 발생하면 어떤 조치를 취해야 하나요?
    


23. **알고리즘의 시간 복잡도와 공간 복잡도의 개념, 그리고 빅오 표기법에 대해 설명해주세요.**

    
    

    23-1. O(n)과 O(log n)의 차이는 무엇인가요?
    


24. **자주 사용되는 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)의 동작 원리와 시간 복잡도를 설명해주세요.**
    
    


25. **이진 탐색의 원리와 시간 복잡도에 대해 설명해주세요.**
    
    


26. **동적 프로그래밍(Dynamic Programming)의 개념을 설명해주세요.**
    
    


27. **자료구조의 종류와 iOS 개발에서 자주 사용되는 자료구조에 대해 설명해주세요.**
    
    


28. **배열, 연결 리스트, 스택, 큐의 특징과 iOS에서의 구현 방법을 설명해주세요.**
    
    


29. **해시 테이블의 개념과 충돌 해결 방법을 설명해주세요.**
    
    


30. **암호화와 보안의 기본 개념, 그리고 iOS 앱 보안을 위한 방안에 대해 설명해주세요.**
    
31. **가상 메모리(Virtual Memory)의 개념과 동작 원리에 대해 설명해주세요.**
    
32. **데이터베이스의 종류와 iOS에서 주로 사용되는 데이터베이스에 대해 설명해주세요.**
    
33. **싱글톤 패턴(Singleton Pattern)이란 무엇이며, 어떤 경우에 사용하나요?**
    
34. **Swift에서 싱글톤 패턴을 구현할 때 멀티스레드에 대해서 어떻게 고려해야 하나요?**
    
35. **Array와 List의 차이점이 무엇인지 설명해주세요.**




https://github.com/JeaSungLEE/iOSInterviewquestions
